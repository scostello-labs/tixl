using System;
using System.Collections.Generic;
using ManagedBass;
using T3.Core.Logging;
using T3.Core.Utils;

namespace T3.Core.Audio;

/// <summary>
/// Analyze audio input from internal soundtrack or from selected Wasapi device.
/// Transforms the FFT buffer generated by BASS and generates frequency bands and peaks.
/// </summary>
public static class AudioAnalysis
{
    internal static void ProcessUpdate(float gainFactor = 1f, float decayFactor = 0.9f)
    {
        var lastTargetIndex = -1;

        lock (FrequencyBands)
        {
            for (var binIndex = 0; binIndex < AudioConfig.FftBufferSize; binIndex++)
            {
                var gain = FftGainBuffer[binIndex] * gainFactor;
                var gainDb = gain <= 0.000001f ? float.NegativeInfinity : 20 * MathF.Log10(gain);

                var normalizedValue = gainDb.RemapAndClamp(-80, 0, 0, 1);
                FftNormalizedBuffer[binIndex] = normalizedValue;

                var bandIndex = _bandIndexForFftBinIndices[binIndex];
                if (bandIndex == NoBandIndex)
                    continue;

                if (bandIndex != lastTargetIndex)
                {
                    FrequencyBands[bandIndex] = 0;
                    lastTargetIndex = bandIndex;
                }

                FrequencyBands[bandIndex] = MathF.Max(FrequencyBands[bandIndex], normalizedValue);
            }
        }

        UpdateSlidingWindowAverages();

        lock (FrequencyBandPeaks)
        {
            // Update Peaks
            for (var bandIndex = 0; bandIndex < AudioConfig.FrequencyBandCount; bandIndex++)
            {
                // Compute Attacks for AudioReaction.
                // This method lacks predictably 
                {
                    var lastPeak = FrequencyBandPeaks[bandIndex];
                    var decayed = lastPeak * decayFactor;
                    var currentValue = FrequencyBands[bandIndex];
                    var newPeak = MathF.Max(decayed, currentValue);
                    FrequencyBandPeaks[bandIndex] = newPeak;

                    const float attackAmplification = 4;
                    var newAttack = (newPeak - lastPeak).Clamp(0, 10000) * attackAmplification;
                    var lastAttackDecayed = FrequencyBandAttacks[bandIndex] * decayFactor;
                    FrequencyBandAttacks[bandIndex] = MathF.Max(newAttack, lastAttackDecayed);
                }

                FrequencyBandAttackPeaks[bandIndex] = MathF.Max(FrequencyBandAttackPeaks[bandIndex] * 0.995f, FrequencyBandAttacks[bandIndex]);

                // Compute onsets for BeatSynchronization
                {
                    var lastValue = _frequencyBandsPrevious[bandIndex];
                    var smoothed = _frequencyBandAverages[bandIndex];
                    var newValueAboveAverage = FrequencyBands[bandIndex] - smoothed;
                    _frequencyBandsPrevious[bandIndex] = newValueAboveAverage;

                    var delta = (newValueAboveAverage - lastValue).Clamp(0, 1000) * 2;
                    FrequencyBandOnSets[bandIndex] = delta;
                }
            }
        }
    }

    /// <summary>
    /// To convert the fft-buffer into a logarithmic tonal scale similar to the octaves on a keyboard
    /// we have to accumulate the fft-values into bins of increasing width. This method generated a look-up
    /// mapping between fft-value and frequency bin.
    /// </summary>
    private static int[] InitializeBandsLookupsTable()
    {
        var r = new int[AudioConfig.FftBufferSize];
        const float lowestBandFrequency = 55;
        const float highestBandFrequency = 15000;

        var maxOctave = MathF.Log2(highestBandFrequency / lowestBandFrequency);
        for (var i = 0; i < AudioConfig.FftBufferSize; i++)
        {
            var bandIndex = NoBandIndex;
            var freq = (float)i / AudioConfig.FftBufferSize * (AudioConfig.MixerFrequency / 2f);

            switch (i)
            {
                case 0:
                    break;

                // For low frequency bin we fake a direct mapping to avoid gaps
                case < 6:
                    bandIndex = i - 1;
                    break;
                default:
                {
                    var octave = MathF.Log2(freq / lowestBandFrequency);
                    var octaveNormalized = octave / maxOctave;
                    bandIndex = (int)(octaveNormalized * AudioConfig.FrequencyBandCount);
                    if (bandIndex >= AudioConfig.FrequencyBandCount)
                        bandIndex = NoBandIndex;
                    break;
                }
            }

            r[i] = bandIndex;
        }

        return r;
    }

    #region compute sliding window average for bins
    private static Queue<float>[] InitHistoryBuffers()
    {
        var r = new Queue<float>[AudioConfig.FrequencyBandCount];
        for (var i = 0; i < AudioConfig.FrequencyBandCount; i++)
        {
            r[i] = new Queue<float>(FrequencyBandHistoryLength);
        }

        return r;
    }

    //private const float AudioUpdatesPerFrame = (float)(60000.0 / 48000);
    private const float EstimatedAudioUpdatePeriod = 0.003f; // roughly 4 sec
    private const int FrequencyBandHistoryLength = (int)(1 / EstimatedAudioUpdatePeriod);

    private static void UpdateSlidingWindowAverages()
    {
        for (var i = 0; i < AudioConfig.FrequencyBandCount; i++)
        {
            var currentStrength = FrequencyBands[i];
            _frequencyBandHistories[i].Enqueue(currentStrength);
            _bandStrengthSums[i] += currentStrength;

            if (_frequencyBandHistories[i].Count > FrequencyBandHistoryLength)
            {
                _bandStrengthSums[i] -= _frequencyBandHistories[i].Dequeue();
            }

            var averageStrength = 0f;
            if (_frequencyBandHistories[i].Count > 0)
            {
                averageStrength = _bandStrengthSums[i] / _frequencyBandHistories[i].Count;
            }

            _frequencyBandAverages[i] = averageStrength;
        }
    }

    private static readonly Queue<float>[] _frequencyBandHistories = InitHistoryBuffers();
    private static readonly float[] _bandStrengthSums = new float[FrequencyBandHistoryLength];
    private static readonly float[] _frequencyBandAverages = new float[FrequencyBandHistoryLength];
    #endregion

    private static readonly int[] _bandIndexForFftBinIndices = InitializeBandsLookupsTable();
    private const int NoBandIndex = -1;

    public static readonly float[] FrequencyBands = new float[AudioConfig.FrequencyBandCount];
    public static readonly float[] FrequencyBandPeaks = new float[AudioConfig.FrequencyBandCount];

    public static readonly float[] FrequencyBandAttacks = new float[AudioConfig.FrequencyBandCount];

    private static readonly float[] _frequencyBandsPrevious = new float[AudioConfig.FrequencyBandCount];
    public static readonly float[] FrequencyBandAttackPeaks = new float[AudioConfig.FrequencyBandCount];

    /// <summary>
    /// Used by  BeatSynchronization
    /// </summary>
    internal static readonly float[] FrequencyBandOnSets = new float[AudioConfig.FrequencyBandCount];

    /// <summary>
    /// Result of the fft analysis in gain
    /// </summary>
    public static readonly float[] FftGainBuffer = new float[AudioConfig.FftBufferSize];

    /// <summary>
    /// Result of the fft analysis converted to db and mapped to a normalized range   
    /// </summary>
    public static readonly float[] FftNormalizedBuffer = new float[AudioConfig.FftBufferSize];

    internal const DataFlags BassFlagForFftBufferSize = DataFlags.FFT2048;
    internal const int FftBufferSize = 1024; // For Bass DataFlags.FFT2024

    /// <summary>
    /// Computes FFT from a PCM buffer during export.
    /// Creates a temporary stream, populates it with the buffer data, and extracts FFT.
    /// </summary>
    /// <param name="pcmBuffer">Interleaved stereo float buffer</param>
    public static void ComputeFftFromBuffer(float[] pcmBuffer)
    {
        if (pcmBuffer == null || pcmBuffer.Length < 4)
        {
            Array.Clear(FftGainBuffer, 0, FftGainBuffer.Length);
            return;
        }

        // Create a temporary push stream
        int tempStream = Bass.CreateStream(
            AudioConfig.MixerFrequency,
            2, // stereo
            BassFlags.Float | BassFlags.Decode,
            StreamProcedureType.Push);

        if (tempStream == 0)
        {
            Log.Warning($"[AudioAnalysis] Failed to create temp stream for FFT: {Bass.LastError}");
            return;
        }

        try
        {
            // Push the PCM data into the stream
            int bytesToPush = pcmBuffer.Length * sizeof(float);
            Bass.StreamPutData(tempStream, pcmBuffer, bytesToPush);

            // Get FFT data from the stream
            Bass.ChannelGetData(tempStream, FftGainBuffer, (int)DataFlags.FFT2048);
        }
        finally
        {
            // Clean up the temporary stream
            Bass.StreamFree(tempStream);
        }
    }
}